
proc found { thing } {
	puts stderr "FOUND(${thing})"
}


######
# Begin autogenerated fickle (version 2.04) routines.
# Although fickle itself is protected by the GNU Public License (GPL)
# all user-supplied functions are protected by their respective
# author's license.  See http://mini.net/tcl/fickle for other details.
######

# If yywrap() returns false (zero), then it is assumed that the
# function has gone ahead and set up yyin to point to another input
# file, and scanning continues.  If it returns true (non-zero), then
# the scanner terminates, returning 0 to its caller.  Note that in
# either case, the start condition remains unchanged; it does not
# revert to INITIAL.
#   -- from the flex(1) man page
proc yywrap {} {
    return 1
}

# ECHO copies yytext to the scanner's output if no arguments are
# given.  The scanner writes its ECHO output to the yyout global
# (default, stdout), which may be redefined by the user simply by
# assigning it to some other channel.
#   -- from the flex(1) man page
proc ECHO {{s ""}} {
    if {$s == ""} {
        puts -nonewline $::yyout $::yytext
    } else {
        puts -nonewline $::yyout $s
    }
}

# YY_FLUSH_BUFFER flushes the scanner's internal buffer so that the
# next time the scanner attempts to match a token, it will first
# refill the buffer using YY_INPUT.
#   -- from the flex(1) man page
proc YY_FLUSH_BUFFER {} {
    set ::yy_buffer ""
    set ::yy_index 0
    set ::yy_done 0
}

# yyrestart(new_file) may be called to point yyin at the new input
# file.  The switch-over to the new file is immediate (any previously
# buffered-up input is lost).  Note that calling yyrestart with yyin
# as an argument thus throws away the current input buffer and
# continues scanning the same input file.
#   -- from the flex(1) man page
proc yyrestart {new_file} {
    set yyin $new_file
    YY_FLUSH_BUFFER
}

# The nature of how it gets its input can be controlled by defining
# the YY_INPUT macro.  YY_INPUT's calling sequence is
# "YY_INPUT(buf,result,max_size)".  Its action is to place up to
# max_size characters in the character array buf and return in the
# integer variable result either the number of characters read or the
# constant YY_NULL (0 on Unix systems) to indicate EOF.  The default
# YY_INPUT reads from the global file-pointer "yyin".
#   -- from the flex(1) man page
proc YY_INPUT {buf result max_size} {
    upvar $result ret_val
    upvar $buf new_data
    if {$::yyin != ""} {
        set new_data [read $::yyin $max_size]
        set ret_val [string length $new_data]
    } else {
        set new_data ""
        set ret_val 0
    }
}

# yy_scan_string sets up input buffers for scanning in-memory
# strings instead of files.  Note that switching input sources does
# not change the start condition.
#   -- from the flex(1) man page
proc yy_scan_string {str} {
    append ::yy_buffer $str
    set ::yyin ""
}

# unput(c) puts the character c back onto the input stream.  It will
# be the next character scanned.
#   -- from the flex(1) man page
proc unput {c} {
    set s [string range $::yy_buffer 0 [expr {$::yy_index - 1}]]
    append s $c
    set ::yy_buffer [append s [string range $::yy_buffer $::yy_index end]]
}

# Returns all but the first n characters of the current token back to
# the input stream, where they will be rescanned when the scanner
# looks for the next match.  yytext and yyleng are adjusted
# appropriately.
#   -- from the flex(1) man page
proc yyless {n} {
    set s [string range $::yy_buffer 0 [expr {$::yy_index - 1}]]
    append s [string range $::yytext $n end]
    set ::yy_buffer [append s [string range $::yy_buffer $::yy_index end]]
    set ::yytext [string range $::yytext 0 [expr {$n - 1}]]
    set ::yyleng [string length $::yytext]
}

# input() reads the next character from the input stream.
#   -- from the flex(1) man page
proc input {} {
    if {[string length $::yy_buffer] - $::yy_index < 1024} {
       set new_buffer_size 0
       if {$::yy_done == 0} {
           YY_INPUT new_buffer new_buffer_size 1024
           append ::yy_buffer $new_buffer
           if {$new_buffer_size == 0} {
               set ::yy_done 1
           }
       }
       if $::yy_done {
           if {[yywrap] == 0} {
               return [input]
           } elseif {[string length $::yy_buffer] - $::yy_index == 0} {
               return {}
           }
        }
    }
    set c [string index $::yy_buffer $::yy_index]
    incr ::yy_index
    return $c
}

# Pushes the current start condition onto the top of the start
# condition stack and switches to new_state as though you had used
# BEGIN new_state.
#   -- from the flex(1) man page
proc yy_push_state {new_state} {
    lappend ::yy_state_stack $new_state
}

# Pops off the top of the state stack; if the stack is now empty, then
# pushes the state "INITIAL".
#   -- from the flex(1) man page
proc yy_pop_state {} {
    set ::yy_state_stack [lrange $::yy_state_stack 0 end-1]
    if {$::yy_state_stack == ""} {
        yy_push_state INITIAL
    }
}

# Returns the top of the stack without altering the stack's contents.
#   -- from the flex(1) man page
proc yy_top_state {} {
    return [lindex $::yy_state_stack end]
}

# BEGIN followed by the name of a start condition places the scanner
# in the corresponding start condition. . . .Until the next BEGIN
# action is executed, rules with the given start condition will be
# active and rules with other start conditions will be inactive.  If
# the start condition is inclusive, then rules with no start
# conditions at all will also be active.  If it is exclusive, then
# only rules qualified with the start condition will be active.
#   -- from the flex(1) man page
proc BEGIN {new_state {prefix yy}} {
    eval set ::${prefix}_state_stack [lrange \$::${prefix}_state_stack 0 end-1]
    eval lappend ::${prefix}_state_stack $new_state
}

# initialize values used by the lexer
set ::yytext {}
set ::yyleng 0
set ::yy_buffer {}
set ::yy_index 0
set ::yy_done 0
set ::yy_state_stack {}
BEGIN INITIAL
array set ::yy_state_table {MULTICOND1 0 MULTICOND2 0 MULTIEND 0 INITIAL 1 MULTICOND 0}
if {![info exists ::yyin]} {
    set ::yyin "stdin"
}
if {![info exists ::yyout]} {
    set ::yyout "stdout"
}

######
# autogenerated yylex function created by fickle
######

# Whenever yylex() is called, it scans tokens from the global input
# file yyin (which defaults to stdin).  It continues until it either
# reaches an end-of-file (at which point it returns the value 0) or
# one of its actions executes a return statement.
#   -- from the flex(1) man page
proc yylex {} {
    upvar #0 ::yytext yytext
    upvar #0 ::yyleng yyleng
    while {1} {
        set yy_current_state [yy_top_state]
        if {[string length $::yy_buffer] - $::yy_index < 1024} {
            if {$::yy_done == 0} {
                set yy_new_buffer ""
                YY_INPUT yy_new_buffer yy_buffer_size 1024
                append ::yy_buffer $yy_new_buffer
                if {$yy_buffer_size == 0 && \
                        [string length $::yy_buffer] - $::yy_index == 0} {
                    set ::yy_done 1
                }
            }
            if $::yy_done {
                if {[yywrap] == 0} {
                    set ::yy_done 0
                    continue
                } elseif {[string length $::yy_buffer] - $::yy_index == 0} {
                    break
                }
            }            
        }
        set ::yyleng 0
        set yy_matched_rule -1
        # rule 0: \<\@
        if {$::yy_state_table($yy_current_state) && \
                [regexp -start $::yy_index -indices -line  -- {\A(\<\@)} $::yy_buffer yy_match] > 0 && \
                [lindex $yy_match 1] - $::yy_index + 1 > $::yyleng} {
            set ::yytext [string range $::yy_buffer $::yy_index [lindex $yy_match 1]]
            set ::yyleng [string length $::yytext]
            set yy_matched_rule 0
        }
        # rule 1: \@\>
        if {$::yy_state_table($yy_current_state) && \
                [regexp -start $::yy_index -indices -line  -- {\A(\@\>)} $::yy_buffer yy_match] > 0 && \
                [lindex $yy_match 1] - $::yy_index + 1 > $::yyleng} {
            set ::yytext [string range $::yy_buffer $::yy_index [lindex $yy_match 1]]
            set ::yyleng [string length $::yytext]
            set yy_matched_rule 1
        }
        # rule 2: \<[(](.|\n)*[)]>
        if {$::yy_state_table($yy_current_state) && \
                [regexp -start $::yy_index -indices -line  -- {\A(\<[(](.|\n)*[)]>)} $::yy_buffer yy_match] > 0 && \
                [lindex $yy_match 1] - $::yy_index + 1 > $::yyleng} {
            set ::yytext [string range $::yy_buffer $::yy_index [lindex $yy_match 1]]
            set ::yyleng [string length $::yytext]
            set yy_matched_rule 2
        }
        # rule 3: \<\{{ident}\([ 	\n]*[,]{0,1}\)\}>
        if {$::yy_state_table($yy_current_state) && \
                [regexp -start $::yy_index -indices -line  -- {\A(\<\{([a-zA-Z][a-zA-Z_0-9.-]*)\([ 	\n]*[,]{0,1}\)\}>)} $::yy_buffer yy_match] > 0 && \
                [lindex $yy_match 1] - $::yy_index + 1 > $::yyleng} {
            set ::yytext [string range $::yy_buffer $::yy_index [lindex $yy_match 1]]
            set ::yyleng [string length $::yytext]
            set yy_matched_rule 3
        }
        # rule 4: \<\{{ident}\([ 	\n]*({ident}|\<\#{ident}\#\>|{number})[,]{0,1}\)\}>
        if {$::yy_state_table($yy_current_state) && \
                [regexp -start $::yy_index -indices -line  -- {\A(\<\{([a-zA-Z][a-zA-Z_0-9.-]*)\([ 	\n]*(([a-zA-Z][a-zA-Z_0-9.-]*)|\<\#([a-zA-Z][a-zA-Z_0-9.-]*)\#\>|((?=[.]{0,1})[0-9]+))[,]{0,1}\)\}>)} $::yy_buffer yy_match] > 0 && \
                [lindex $yy_match 1] - $::yy_index + 1 > $::yyleng} {
            set ::yytext [string range $::yy_buffer $::yy_index [lindex $yy_match 1]]
            set ::yyleng [string length $::yytext]
            set yy_matched_rule 4
        }
        # rule 5: \<\{{ident}\(({ident}|\<\#{ident}\#\>|{number})([,]({ident}|\<\#{ident}\#\>|{number})){1,}[,]{0,1}\)\}>
        if {$::yy_state_table($yy_current_state) && \
                [regexp -start $::yy_index -indices -line  -- {\A(\<\{([a-zA-Z][a-zA-Z_0-9.-]*)\((([a-zA-Z][a-zA-Z_0-9.-]*)|\<\#([a-zA-Z][a-zA-Z_0-9.-]*)\#\>|((?=[.]{0,1})[0-9]+))([,](([a-zA-Z][a-zA-Z_0-9.-]*)|\<\#([a-zA-Z][a-zA-Z_0-9.-]*)\#\>|((?=[.]{0,1})[0-9]+))){1,}[,]{0,1}\)\}>)} $::yy_buffer yy_match] > 0 && \
                [lindex $yy_match 1] - $::yy_index + 1 > $::yyleng} {
            set ::yytext [string range $::yy_buffer $::yy_index [lindex $yy_match 1]]
            set ::yyleng [string length $::yytext]
            set yy_matched_rule 5
        }
        # rule 6: \<\#\#{ident}\#\#\>
        if {$::yy_state_table($yy_current_state) && \
                [regexp -start $::yy_index -indices -line  -- {\A(\<\#\#([a-zA-Z][a-zA-Z_0-9.-]*)\#\#\>)} $::yy_buffer yy_match] > 0 && \
                [lindex $yy_match 1] - $::yy_index + 1 > $::yyleng} {
            set ::yytext [string range $::yy_buffer $::yy_index [lindex $yy_match 1]]
            set ::yyleng [string length $::yytext]
            set yy_matched_rule 6
        }
        # rule 7: \<\#\<\#{ident}\#\>\#\>
        if {$::yy_state_table($yy_current_state) && \
                [regexp -start $::yy_index -indices -line  -- {\A(\<\#\<\#([a-zA-Z][a-zA-Z_0-9.-]*)\#\>\#\>)} $::yy_buffer yy_match] > 0 && \
                [lindex $yy_match 1] - $::yy_index + 1 > $::yyleng} {
            set ::yytext [string range $::yy_buffer $::yy_index [lindex $yy_match 1]]
            set ::yyleng [string length $::yytext]
            set yy_matched_rule 7
        }
        # rule 8: \<\#{ident}\#\>
        if {$::yy_state_table($yy_current_state) && \
                [regexp -start $::yy_index -indices -line  -- {\A(\<\#([a-zA-Z][a-zA-Z_0-9.-]*)\#\>)} $::yy_buffer yy_match] > 0 && \
                [lindex $yy_match 1] - $::yy_index + 1 > $::yyleng} {
            set ::yytext [string range $::yy_buffer $::yy_index [lindex $yy_match 1]]
            set ::yyleng [string length $::yytext]
            set yy_matched_rule 8
        }
        # rule 9: \<\[{ident}\]\>
        if {$::yy_state_table($yy_current_state) && \
                [regexp -start $::yy_index -indices -line  -- {\A(\<\[([a-zA-Z][a-zA-Z_0-9.-]*)\]\>)} $::yy_buffer yy_match] > 0 && \
                [lindex $yy_match 1] - $::yy_index + 1 > $::yyleng} {
            set ::yytext [string range $::yy_buffer $::yy_index [lindex $yy_match 1]]
            set ::yyleng [string length $::yytext]
            set yy_matched_rule 9
        }
        # rule 10: \<\[<\#{ident}\#>\]\>
        if {$::yy_state_table($yy_current_state) && \
                [regexp -start $::yy_index -indices -line  -- {\A(\<\[<\#([a-zA-Z][a-zA-Z_0-9.-]*)\#>\]\>)} $::yy_buffer yy_match] > 0 && \
                [lindex $yy_match 1] - $::yy_index + 1 > $::yyleng} {
            set ::yytext [string range $::yy_buffer $::yy_index [lindex $yy_match 1]]
            set ::yyleng [string length $::yytext]
            set yy_matched_rule 10
        }
        # rule 11: \<\[{ident}<\#{ident}\#>\]\>
        if {$::yy_state_table($yy_current_state) && \
                [regexp -start $::yy_index -indices -line  -- {\A(\<\[([a-zA-Z][a-zA-Z_0-9.-]*)<\#([a-zA-Z][a-zA-Z_0-9.-]*)\#>\]\>)} $::yy_buffer yy_match] > 0 && \
                [lindex $yy_match 1] - $::yy_index + 1 > $::yyleng} {
            set ::yytext [string range $::yy_buffer $::yy_index [lindex $yy_match 1]]
            set ::yyleng [string length $::yytext]
            set yy_matched_rule 11
        }
        # rule 12: \<\[<\#{ident}\#>{ident}\]\>
        if {$::yy_state_table($yy_current_state) && \
                [regexp -start $::yy_index -indices -line  -- {\A(\<\[<\#([a-zA-Z][a-zA-Z_0-9.-]*)\#>([a-zA-Z][a-zA-Z_0-9.-]*)\]\>)} $::yy_buffer yy_match] > 0 && \
                [lindex $yy_match 1] - $::yy_index + 1 > $::yyleng} {
            set ::yytext [string range $::yy_buffer $::yy_index [lindex $yy_match 1]]
            set ::yyleng [string length $::yytext]
            set yy_matched_rule 12
        }
        # rule 13: \<\[{ident}<\#{ident}\#>{ident}\]\>
        if {$::yy_state_table($yy_current_state) && \
                [regexp -start $::yy_index -indices -line  -- {\A(\<\[([a-zA-Z][a-zA-Z_0-9.-]*)<\#([a-zA-Z][a-zA-Z_0-9.-]*)\#>([a-zA-Z][a-zA-Z_0-9.-]*)\]\>)} $::yy_buffer yy_match] > 0 && \
                [lindex $yy_match 1] - $::yy_index + 1 > $::yyleng} {
            set ::yytext [string range $::yy_buffer $::yy_index [lindex $yy_match 1]]
            set ::yyleng [string length $::yytext]
            set yy_matched_rule 13
        }
        # rule 14: \<=\<\#{ident}\#\>\<=\><`([^`]|\n)+`>=\>
        if {$::yy_state_table($yy_current_state) && \
                [regexp -start $::yy_index -indices -line  -- {\A(\<=\<\#([a-zA-Z][a-zA-Z_0-9.-]*)\#\>\<=\><`([^`]|\n)+`>=\>)} $::yy_buffer yy_match] > 0 && \
                [lindex $yy_match 1] - $::yy_index + 1 > $::yyleng} {
            set ::yytext [string range $::yy_buffer $::yy_index [lindex $yy_match 1]]
            set ::yyleng [string length $::yytext]
            set yy_matched_rule 14
        }
        # rule 15: \<=\<\[{ident}\]\>\<=\>(<`([^`]|\n)+`>,)+=\>
        if {$::yy_state_table($yy_current_state) && \
                [regexp -start $::yy_index -indices -line  -- {\A(\<=\<\[([a-zA-Z][a-zA-Z_0-9.-]*)\]\>\<=\>(<`([^`]|\n)+`>,)+=\>)} $::yy_buffer yy_match] > 0 && \
                [lindex $yy_match 1] - $::yy_index + 1 > $::yyleng} {
            set ::yytext [string range $::yy_buffer $::yy_index [lindex $yy_match 1]]
            set ::yyleng [string length $::yytext]
            set yy_matched_rule 15
        }
        # rule 16: \<\*\>
        if {$::yy_state_table($yy_current_state) && \
                [regexp -start $::yy_index -indices -line  -- {\A(\<\*\>)} $::yy_buffer yy_match] > 0 && \
                [lindex $yy_match 1] - $::yy_index + 1 > $::yyleng} {
            set ::yytext [string range $::yy_buffer $::yy_index [lindex $yy_match 1]]
            set ::yyleng [string length $::yytext]
            set yy_matched_rule 16
        }
        # rule 17: \<\*\?
        if {$::yy_state_table($yy_current_state) && \
                [regexp -start $::yy_index -indices -line  -- {\A(\<\*\?)} $::yy_buffer yy_match] > 0 && \
                [lindex $yy_match 1] - $::yy_index + 1 > $::yyleng} {
            set ::yytext [string range $::yy_buffer $::yy_index [lindex $yy_match 1]]
            set ::yyleng [string length $::yytext]
            set yy_matched_rule 17
        }
        # rule 18: <MULTICOND>\`([^`]|\n)*\`
        if {[lsearch -exact {MULTICOND} $yy_current_state] >= 0 && \
                [regexp -start $::yy_index -indices -line  -- {\A(\`([^`]|\n)*\`)} $::yy_buffer yy_match] > 0 && \
                [lindex $yy_match 1] - $::yy_index + 1 > $::yyleng} {
            set ::yytext [string range $::yy_buffer $::yy_index [lindex $yy_match 1]]
            set ::yyleng [string length $::yytext]
            set yy_matched_rule 18
        }
        # rule 19: <MULTICOND>\<\#{ident}\#\>
        if {[lsearch -exact {MULTICOND} $yy_current_state] >= 0 && \
                [regexp -start $::yy_index -indices -line  -- {\A(\<\#([a-zA-Z][a-zA-Z_0-9.-]*)\#\>)} $::yy_buffer yy_match] > 0 && \
                [lindex $yy_match 1] - $::yy_index + 1 > $::yyleng} {
            set ::yytext [string range $::yy_buffer $::yy_index [lindex $yy_match 1]]
            set ::yyleng [string length $::yytext]
            set yy_matched_rule 19
        }
        # rule 20: <MULTICOND1>:
        if {[lsearch -exact {MULTICOND1} $yy_current_state] >= 0 && \
                [regexp -start $::yy_index -indices -line  -- {\A(:)} $::yy_buffer yy_match] > 0 && \
                [lindex $yy_match 1] - $::yy_index + 1 > $::yyleng} {
            set ::yytext [string range $::yy_buffer $::yy_index [lindex $yy_match 1]]
            set ::yyleng [string length $::yytext]
            set yy_matched_rule 20
        }
        # rule 21: <MULTICOND2>\`([^`]|\n)*\`
        if {[lsearch -exact {MULTICOND2} $yy_current_state] >= 0 && \
                [regexp -start $::yy_index -indices -line  -- {\A(\`([^`]|\n)*\`)} $::yy_buffer yy_match] > 0 && \
                [lindex $yy_match 1] - $::yy_index + 1 > $::yyleng} {
            set ::yytext [string range $::yy_buffer $::yy_index [lindex $yy_match 1]]
            set ::yyleng [string length $::yytext]
            set yy_matched_rule 21
        }
        # rule 22: <MULTICOND2><\#{ident}\#\>
        if {[lsearch -exact {MULTICOND2} $yy_current_state] >= 0 && \
                [regexp -start $::yy_index -indices -line  -- {\A(<\#([a-zA-Z][a-zA-Z_0-9.-]*)\#\>)} $::yy_buffer yy_match] > 0 && \
                [lindex $yy_match 1] - $::yy_index + 1 > $::yyleng} {
            set ::yytext [string range $::yy_buffer $::yy_index [lindex $yy_match 1]]
            set ::yyleng [string length $::yytext]
            set yy_matched_rule 22
        }
        # rule 23: <MULTIEND>\>
        if {[lsearch -exact {MULTIEND} $yy_current_state] >= 0 && \
                [regexp -start $::yy_index -indices -line  -- {\A(\>)} $::yy_buffer yy_match] > 0 && \
                [lindex $yy_match 1] - $::yy_index + 1 > $::yyleng} {
            set ::yytext [string range $::yy_buffer $::yy_index [lindex $yy_match 1]]
            set ::yyleng [string length $::yytext]
            set yy_matched_rule 23
        }
        # rule 24: [{]{digits}[}]
        if {$::yy_state_table($yy_current_state) && \
                [regexp -start $::yy_index -indices -line  -- {\A([{]([0-9]+)[}])} $::yy_buffer yy_match] > 0 && \
                [lindex $yy_match 1] - $::yy_index + 1 > $::yyleng} {
            set ::yytext [string range $::yy_buffer $::yy_index [lindex $yy_match 1]]
            set ::yyleng [string length $::yytext]
            set yy_matched_rule 24
        }
        # rule 25: [{]({digits}|random),[}]
        if {$::yy_state_table($yy_current_state) && \
                [regexp -start $::yy_index -indices -line  -- {\A([{](([0-9]+)|random),[}])} $::yy_buffer yy_match] > 0 && \
                [lindex $yy_match 1] - $::yy_index + 1 > $::yyleng} {
            set ::yytext [string range $::yy_buffer $::yy_index [lindex $yy_match 1]]
            set ::yyleng [string length $::yytext]
            set yy_matched_rule 25
        }
        # rule 26: [{],{digits}[}]
        if {$::yy_state_table($yy_current_state) && \
                [regexp -start $::yy_index -indices -line  -- {\A([{],([0-9]+)[}])} $::yy_buffer yy_match] > 0 && \
                [lindex $yy_match 1] - $::yy_index + 1 > $::yyleng} {
            set ::yytext [string range $::yy_buffer $::yy_index [lindex $yy_match 1]]
            set ::yyleng [string length $::yytext]
            set yy_matched_rule 26
        }
        # rule 27: [{]({digits}|random),{digits}[}]
        if {$::yy_state_table($yy_current_state) && \
                [regexp -start $::yy_index -indices -line  -- {\A([{](([0-9]+)|random),([0-9]+)[}])} $::yy_buffer yy_match] > 0 && \
                [lindex $yy_match 1] - $::yy_index + 1 > $::yyleng} {
            set ::yytext [string range $::yy_buffer $::yy_index [lindex $yy_match 1]]
            set ::yyleng [string length $::yytext]
            set yy_matched_rule 27
        }
        # rule 28: [{]({digits}|random),[+]{digits}[}]
        if {$::yy_state_table($yy_current_state) && \
                [regexp -start $::yy_index -indices -line  -- {\A([{](([0-9]+)|random),[+]([0-9]+)[}])} $::yy_buffer yy_match] > 0 && \
                [lindex $yy_match 1] - $::yy_index + 1 > $::yyleng} {
            set ::yytext [string range $::yy_buffer $::yy_index [lindex $yy_match 1]]
            set ::yyleng [string length $::yytext]
            set yy_matched_rule 28
        }
        # rule 29: \<\`([^`]|\n)*\`\>
        if {$::yy_state_table($yy_current_state) && \
                [regexp -start $::yy_index -indices -line  -- {\A(\<\`([^`]|\n)*\`\>)} $::yy_buffer yy_match] > 0 && \
                [lindex $yy_match 1] - $::yy_index + 1 > $::yyleng} {
            set ::yytext [string range $::yy_buffer $::yy_index [lindex $yy_match 1]]
            set ::yyleng [string length $::yytext]
            set yy_matched_rule 29
        }
        # rule 30: \<\?([^\?]|\n)+\?\>
        if {$::yy_state_table($yy_current_state) && \
                [regexp -start $::yy_index -indices -line  -- {\A(\<\?([^\?]|\n)+\?\>)} $::yy_buffer yy_match] > 0 && \
                [lindex $yy_match 1] - $::yy_index + 1 > $::yyleng} {
            set ::yytext [string range $::yy_buffer $::yy_index [lindex $yy_match 1]]
            set ::yyleng [string length $::yytext]
            set yy_matched_rule 30
        }
        # rule 31: \<\+\>
        if {$::yy_state_table($yy_current_state) && \
                [regexp -start $::yy_index -indices -line  -- {\A(\<\+\>)} $::yy_buffer yy_match] > 0 && \
                [lindex $yy_match 1] - $::yy_index + 1 > $::yyleng} {
            set ::yytext [string range $::yy_buffer $::yy_index [lindex $yy_match 1]]
            set ::yyleng [string length $::yytext]
            set yy_matched_rule 31
        }
        # rule 32: \<\-\>
        if {$::yy_state_table($yy_current_state) && \
                [regexp -start $::yy_index -indices -line  -- {\A(\<\-\>)} $::yy_buffer yy_match] > 0 && \
                [lindex $yy_match 1] - $::yy_index + 1 > $::yyleng} {
            set ::yytext [string range $::yy_buffer $::yy_index [lindex $yy_match 1]]
            set ::yyleng [string length $::yytext]
            set yy_matched_rule 32
        }
        if {$yy_matched_rule == -1} {
            set ::yytext [string index $::yy_buffer $::yy_index]
            set ::yyleng 1
        }
        incr ::yy_index $::yyleng
        # workaround for Tcl's circumflex behavior
        if {[string index $::yytext end] == "\n"} {
            set ::yy_buffer [string range $::yy_buffer $::yy_index end]
            set ::yy_index 0
        }
        switch -- $yy_matched_rule {
            0 {
lappend ::rtnlist "EO"
            }
            1 {
lappend ::rtnlist "EC"
            }
            2 {
lappend ::rtnlist [list group $yytext]
            }
            3 {
lappend ::rtnlist [list func0 $yytext]
            }
            4 {
lappend ::rtnlist [list funcN $yytext]
            }
            5 {
lappend ::rtnlist [list funcN $yytext]
            }
            6 {
lappend ::rtnlist [list ridef $yytext]
            }
            7 {
lappend ::rtnlist [list idef $yytext]
            }
            8 {
lappend ::rtnlist [list def $yytext]
            }
            9 {
lappend ::rtnlist [list array $yytext]
            }
            10 {
lappend ::rtnlist [list indirectarray $yytext]
            }
            11 {
lappend ::rtnlist [list indirectarray $yytext]
            }
            12 {
lappend ::rtnlist [list indirectarray $yytext]
            }
            13 {
lappend ::rtnlist [list indirectarray $yytext]
            }
            14 {
lappend ::rtnlist [list assignvar $yytext]
            }
            15 {
lappend ::rtnlist [list assignlist $yytext]
            }
            16 {
lappend ::rtnlist "multi"
            }
            17 {
yy_push_state MULTICOND;
            }
            18 {
yy_push_state MULTICOND1; set ::multi_tt text; set ::multi_true_text $yytext
            }
            19 {
yy_push_state MULTICOND1; set ::multi_tt var; set ::multi_true_text $yytext
            }
            20 {
yy_push_state MULTICOND2;
            }
            21 {
yy_push_state MULTIEND; set ::multi_ft text; set ::multi_false_text $yytext
            }
            22 {
yy_push_state MULTIEND; set ::multi_ft var; set ::multi_false_text $yytext
            }
            23 {
yy_pop_state;yy_pop_state;yy_pop_state;yy_pop_state;lappend ::rtnlist [list "multiCond" "${::multi_true_text}:${::multi_false_text}" $::multi_tt $::multi_true_text $::multi_ft $::multi_false_text]
            }
            24 {
lappend ::rtnlist [list range1 $yytext]
            }
            25 {
lappend ::rtnlist [list range2 $yytext]
            }
            26 {
lappend ::rtnlist [list range3 $yytext]
            }
            27 {
lappend ::rtnlist [list range4 $yytext]
            }
            28 {
lappend ::rtnlist [list range5 $yytext]
            }
            29 {
lappend ::rtnlist [list text $yytext]
            }
            30 {
lappend ::rtnlist [list conditional $yytext]
            }
            31 {
lappend ::rtnlist "condtrue"
            }
            32 {
lappend ::rtnlist "condfalse"
            }
            default
                { ECHO }
        }
    }
    return 0
}
######
# end autogenerated fickle functions
######


proc scanString { str } {
   lappend ::rtnlist junk
   unset ::rtnlist
   set ::rtnlist ""
   yy_scan_string ${str}
   # {<@<#definition#><*><[words]>@><@<#something#><*><[qaz]>@>}

   yylex
   lappend rtnlist [list end]
   return $::rtnlist
}
